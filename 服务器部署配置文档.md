# Coach Daily - 服务器部署配置文档

## 目录
- [方案选择](#方案选择)
- [推荐方案：Node.js + Express + SQLite](#推荐方案nodejs--express--sqlite)
- [服务器端完整实现](#服务器端完整实现)
- [服务器部署步骤](#服务器部署步骤)
- [客户端集成指南](#客户端集成指南)
- [安全性配置](#安全性配置)
- [备份与恢复](#备份与恢复)
- [监控与日志](#监控与日志)
- [常见问题排查](#常见问题排查)
- [其他可选方案](#其他可选方案)

---

## 方案选择

### 方案对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **Node.js + Express + SQLite** | 轻量、部署简单、无需额外数据库服务、资源占用少（~50MB内存） | 并发性能有限（单机足够） | **个人使用、小团队** ✅ 推荐 |
| **Docker + FastAPI + PostgreSQL** | 规范、扩展性强、支持复杂查询 | 资源占用大（~500MB+内存）、配置复杂 | 团队协作、高并发需求 |
| **Supabase 自托管** | 功能全面（认证、存储、实时订阅） | 资源占用非常大（1GB+内存）、配置复杂 | 需要完整后端服务的场景 |

### 推荐选择：方案一（Node.js + Express + SQLite）

**理由：**
1. **最轻量**：适合个人云服务器（1核2GB即可流畅运行）
2. **部署简单**：无需配置独立数据库服务
3. **维护成本低**：代码简洁，易于理解和修改
4. **性能足够**：对于个人日常追踪应用，SQLite完全够用
5. **成本最低**：无额外服务费用

---

## 推荐方案：Node.js + Express + SQLite

### 技术栈
- **运行环境**：Node.js 18+
- **Web框架**：Express 4.x
- **数据库**：SQLite 3
- **认证**：JWT (JSON Web Token)
- **进程管理**：PM2
- **反向代理**：Nginx
- **SSL证书**：Let's Encrypt (免费)

### 架构图
```
┌─────────────┐
│ Flutter App │
└──────┬──────┘
       │ HTTPS
       ↓
┌─────────────┐
│   Nginx     │ ← SSL终止、反向代理
└──────┬──────┘
       │
       ↓
┌─────────────┐
│  PM2 + Node │ ← Express API服务
└──────┬──────┘
       │
       ↓
┌─────────────┐
│   SQLite    │ ← 数据持久化
└─────────────┘
```

---

## 服务器端完整实现

### 1. 项目结构

```bash
coach-daily-server/
├── package.json
├── ecosystem.config.js      # PM2配置
├── .env                      # 环境变量
├── src/
│   ├── index.js             # 入口文件
│   ├── config/
│   │   └── database.js      # 数据库配置
│   ├── middleware/
│   │   ├── auth.js          # JWT认证中间件
│   │   └── errorHandler.js # 错误处理
│   ├── routes/
│   │   ├── auth.js          # 认证路由
│   │   ├── reviews.js       # 每日回顾
│   │   ├── workouts.js      # 运动记录
│   │   ├── meals.js         # 饮食记录
│   │   ├── sleep.js         # 睡眠记录
│   │   ├── focus.js         # 专注工作
│   │   └── sync.js          # 数据同步
│   └── utils/
│       ├── jwt.js           # JWT工具
│       └── logger.js        # 日志工具
└── data/
    └── coach_daily.db       # SQLite数据库文件
```

### 2. 核心代码实现

#### 2.1 package.json

```json
{
  "name": "coach-daily-server",
  "version": "1.0.0",
  "description": "Coach Daily API Server",
  "main": "src/index.js",
  "scripts": {
    "start": "node src/index.js",
    "dev": "nodemon src/index.js",
    "init-db": "node src/scripts/initDatabase.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "better-sqlite3": "^9.2.2",
    "jsonwebtoken": "^9.0.2",
    "bcryptjs": "^2.4.3",
    "dotenv": "^16.3.1",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "express-rate-limit": "^7.1.5",
    "uuid": "^9.0.1",
    "winston": "^3.11.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.2"
  }
}
```

#### 2.2 .env (环境变量配置)

```bash
# 服务器配置
PORT=3000
NODE_ENV=production

# JWT配置
JWT_SECRET=your_super_secret_key_change_this_in_production_min_32_chars
JWT_EXPIRES_IN=30d

# 数据库配置
DB_PATH=./data/coach_daily.db

# CORS配置（允许的客户端域名）
ALLOWED_ORIGINS=https://yourdomain.com,http://localhost:*
```

#### 2.3 src/config/database.js

```javascript
const Database = require('better-sqlite3');
const path = require('path');
const fs = require('fs');

const dbPath = process.env.DB_PATH || './data/coach_daily.db';
const dbDir = path.dirname(dbPath);

// 确保数据目录存在
if (!fs.existsSync(dbDir)) {
  fs.mkdirSync(dbDir, { recursive: true });
}

const db = new Database(dbPath, { verbose: console.log });

// 启用WAL模式（提高并发性能）
db.pragma('journal_mode = WAL');

// 初始化数据库表结构
function initDatabase() {
  // 用户表
  db.exec(`
    CREATE TABLE IF NOT EXISTS users (
      id TEXT PRIMARY KEY,
      username TEXT UNIQUE NOT NULL,
      password_hash TEXT NOT NULL,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
    );
  `);

  // 每日回顾表
  db.exec(`
    CREATE TABLE IF NOT EXISTS review_entries (
      id TEXT PRIMARY KEY,
      user_id TEXT NOT NULL,
      date TEXT NOT NULL,
      mood TEXT NOT NULL,
      highlights TEXT,
      improvements TEXT,
      tomorrow_plans TEXT,
      ai_summary TEXT,
      note TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
    );
    CREATE INDEX IF NOT EXISTS idx_review_user_date ON review_entries(user_id, date);
  `);

  // 运动记录表
  db.exec(`
    CREATE TABLE IF NOT EXISTS workout_records (
      id TEXT PRIMARY KEY,
      user_id TEXT NOT NULL,
      type TEXT NOT NULL,
      start_time TEXT NOT NULL,
      duration_minutes INTEGER NOT NULL,
      distance_km REAL NOT NULL,
      calories_kcal INTEGER NOT NULL,
      notes TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
    );
    CREATE INDEX IF NOT EXISTS idx_workout_user_time ON workout_records(user_id, start_time);
  `);

  // 饮食记录表
  db.exec(`
    CREATE TABLE IF NOT EXISTS meal_records (
      id TEXT PRIMARY KEY,
      user_id TEXT NOT NULL,
      meal_type TEXT NOT NULL,
      timestamp TEXT NOT NULL,
      notes TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
    );
    CREATE INDEX IF NOT EXISTS idx_meal_user_time ON meal_records(user_id, timestamp);
  `);

  // 食物项表
  db.exec(`
    CREATE TABLE IF NOT EXISTS food_items (
      id TEXT PRIMARY KEY,
      meal_id TEXT NOT NULL,
      name TEXT NOT NULL,
      calories INTEGER NOT NULL,
      protein REAL NOT NULL,
      carbs REAL NOT NULL,
      fat REAL NOT NULL,
      image_url TEXT,
      FOREIGN KEY (meal_id) REFERENCES meal_records(id) ON DELETE CASCADE
    );
    CREATE INDEX IF NOT EXISTS idx_food_meal ON food_items(meal_id);
  `);

  // 睡眠记录表
  db.exec(`
    CREATE TABLE IF NOT EXISTS sleep_records (
      id TEXT PRIMARY KEY,
      user_id TEXT NOT NULL,
      date TEXT NOT NULL,
      bedtime TEXT NOT NULL,
      wake_time TEXT NOT NULL,
      note TEXT,
      sleep_quality INTEGER,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
    );
    CREATE INDEX IF NOT EXISTS idx_sleep_user_date ON sleep_records(user_id, date);
  `);

  // 专注工作表
  db.exec(`
    CREATE TABLE IF NOT EXISTS focus_sessions (
      id TEXT PRIMARY KEY,
      user_id TEXT NOT NULL,
      start_time TEXT NOT NULL,
      end_time TEXT NOT NULL,
      target_minutes INTEGER NOT NULL,
      task_name TEXT,
      completed INTEGER DEFAULT 0,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
    );
    CREATE INDEX IF NOT EXISTS idx_focus_user_time ON focus_sessions(user_id, start_time);
  `);

  console.log('Database initialized successfully');
}

module.exports = { db, initDatabase };
```

#### 2.4 src/middleware/auth.js

```javascript
const { verifyToken } = require('../utils/jwt');

function authMiddleware(req, res, next) {
  try {
    const authHeader = req.headers.authorization;

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'No token provided' });
    }

    const token = authHeader.substring(7);
    const decoded = verifyToken(token);

    req.userId = decoded.userId;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid or expired token' });
  }
}

module.exports = authMiddleware;
```

#### 2.5 src/middleware/errorHandler.js

```javascript
function errorHandler(err, req, res, next) {
  console.error('Error:', err);

  if (err.name === 'ValidationError') {
    return res.status(400).json({ error: err.message });
  }

  if (err.code === 'SQLITE_CONSTRAINT') {
    return res.status(409).json({ error: 'Data constraint violation' });
  }

  res.status(500).json({
    error: process.env.NODE_ENV === 'production'
      ? 'Internal server error'
      : err.message
  });
}

module.exports = errorHandler;
```

#### 2.6 src/utils/jwt.js

```javascript
const jwt = require('jsonwebtoken');

const JWT_SECRET = process.env.JWT_SECRET;
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '30d';

function generateToken(userId) {
  return jwt.sign({ userId }, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });
}

function verifyToken(token) {
  return jwt.verify(token, JWT_SECRET);
}

module.exports = { generateToken, verifyToken };
```

#### 2.7 src/routes/auth.js

```javascript
const express = require('express');
const bcrypt = require('bcryptjs');
const { v4: uuidv4 } = require('uuid');
const { db } = require('../config/database');
const { generateToken } = require('../utils/jwt');

const router = express.Router();

// 注册
router.post('/register', async (req, res, next) => {
  try {
    const { username, password } = req.body;

    if (!username || !password) {
      return res.status(400).json({ error: 'Username and password are required' });
    }

    if (password.length < 6) {
      return res.status(400).json({ error: 'Password must be at least 6 characters' });
    }

    const userId = uuidv4();
    const passwordHash = await bcrypt.hash(password, 10);

    const stmt = db.prepare(`
      INSERT INTO users (id, username, password_hash)
      VALUES (?, ?, ?)
    `);

    stmt.run(userId, username, passwordHash);

    const token = generateToken(userId);

    res.status(201).json({
      token,
      userId,
      username
    });
  } catch (error) {
    if (error.code === 'SQLITE_CONSTRAINT_UNIQUE') {
      return res.status(409).json({ error: 'Username already exists' });
    }
    next(error);
  }
});

// 登录
router.post('/login', async (req, res, next) => {
  try {
    const { username, password } = req.body;

    if (!username || !password) {
      return res.status(400).json({ error: 'Username and password are required' });
    }

    const stmt = db.prepare('SELECT * FROM users WHERE username = ?');
    const user = stmt.get(username);

    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const isValidPassword = await bcrypt.compare(password, user.password_hash);

    if (!isValidPassword) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const token = generateToken(user.id);

    res.json({
      token,
      userId: user.id,
      username: user.username
    });
  } catch (error) {
    next(error);
  }
});

module.exports = router;
```

#### 2.8 src/routes/reviews.js

```javascript
const express = require('express');
const { db } = require('../config/database');
const authMiddleware = require('../middleware/auth');

const router = express.Router();

// 所有路由都需要认证
router.use(authMiddleware);

// 获取所有回顾记录
router.get('/', (req, res, next) => {
  try {
    const { startDate, endDate, limit = 100 } = req.query;

    let query = 'SELECT * FROM review_entries WHERE user_id = ?';
    const params = [req.userId];

    if (startDate) {
      query += ' AND date >= ?';
      params.push(startDate);
    }

    if (endDate) {
      query += ' AND date <= ?';
      params.push(endDate);
    }

    query += ' ORDER BY date DESC LIMIT ?';
    params.push(parseInt(limit));

    const stmt = db.prepare(query);
    const entries = stmt.all(...params);

    // 转换JSON字段
    const formatted = entries.map(entry => ({
      ...entry,
      highlights: entry.highlights ? JSON.parse(entry.highlights) : [],
      improvements: entry.improvements ? JSON.parse(entry.improvements) : [],
      tomorrowPlans: entry.tomorrow_plans ? JSON.parse(entry.tomorrow_plans) : []
    }));

    res.json(formatted);
  } catch (error) {
    next(error);
  }
});

// 获取单个回顾记录
router.get('/:id', (req, res, next) => {
  try {
    const stmt = db.prepare(`
      SELECT * FROM review_entries
      WHERE id = ? AND user_id = ?
    `);
    const entry = stmt.get(req.params.id, req.userId);

    if (!entry) {
      return res.status(404).json({ error: 'Review entry not found' });
    }

    const formatted = {
      ...entry,
      highlights: entry.highlights ? JSON.parse(entry.highlights) : [],
      improvements: entry.improvements ? JSON.parse(entry.improvements) : [],
      tomorrowPlans: entry.tomorrow_plans ? JSON.parse(entry.tomorrow_plans) : []
    };

    res.json(formatted);
  } catch (error) {
    next(error);
  }
});

// 创建或更新回顾记录
router.post('/', (req, res, next) => {
  try {
    const { id, date, mood, highlights, improvements, tomorrowPlans, aiSummary, note } = req.body;

    if (!id || !date || !mood) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const stmt = db.prepare(`
      INSERT INTO review_entries
      (id, user_id, date, mood, highlights, improvements, tomorrow_plans, ai_summary, note, updated_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
      ON CONFLICT(id) DO UPDATE SET
        mood = excluded.mood,
        highlights = excluded.highlights,
        improvements = excluded.improvements,
        tomorrow_plans = excluded.tomorrow_plans,
        ai_summary = excluded.ai_summary,
        note = excluded.note,
        updated_at = CURRENT_TIMESTAMP
    `);

    stmt.run(
      id,
      req.userId,
      date,
      mood,
      JSON.stringify(highlights || []),
      JSON.stringify(improvements || []),
      JSON.stringify(tomorrowPlans || []),
      aiSummary,
      note
    );

    res.status(201).json({ success: true, id });
  } catch (error) {
    next(error);
  }
});

// 删除回顾记录
router.delete('/:id', (req, res, next) => {
  try {
    const stmt = db.prepare(`
      DELETE FROM review_entries
      WHERE id = ? AND user_id = ?
    `);
    const result = stmt.run(req.params.id, req.userId);

    if (result.changes === 0) {
      return res.status(404).json({ error: 'Review entry not found' });
    }

    res.json({ success: true });
  } catch (error) {
    next(error);
  }
});

module.exports = router;
```

#### 2.9 src/routes/workouts.js

```javascript
const express = require('express');
const { db } = require('../config/database');
const authMiddleware = require('../middleware/auth');

const router = express.Router();
router.use(authMiddleware);

// 获取所有运动记录
router.get('/', (req, res, next) => {
  try {
    const { startDate, endDate, limit = 100 } = req.query;

    let query = 'SELECT * FROM workout_records WHERE user_id = ?';
    const params = [req.userId];

    if (startDate) {
      query += ' AND start_time >= ?';
      params.push(startDate);
    }

    if (endDate) {
      query += ' AND start_time <= ?';
      params.push(endDate);
    }

    query += ' ORDER BY start_time DESC LIMIT ?';
    params.push(parseInt(limit));

    const stmt = db.prepare(query);
    const records = stmt.all(...params);

    res.json(records);
  } catch (error) {
    next(error);
  }
});

// 创建或更新运动记录
router.post('/', (req, res, next) => {
  try {
    const { id, type, startTime, durationMinutes, distanceKm, caloriesKcal, notes } = req.body;

    if (!id || !type || !startTime || durationMinutes === undefined) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const stmt = db.prepare(`
      INSERT INTO workout_records
      (id, user_id, type, start_time, duration_minutes, distance_km, calories_kcal, notes, updated_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
      ON CONFLICT(id) DO UPDATE SET
        type = excluded.type,
        start_time = excluded.start_time,
        duration_minutes = excluded.duration_minutes,
        distance_km = excluded.distance_km,
        calories_kcal = excluded.calories_kcal,
        notes = excluded.notes,
        updated_at = CURRENT_TIMESTAMP
    `);

    stmt.run(id, req.userId, type, startTime, durationMinutes, distanceKm || 0, caloriesKcal || 0, notes);

    res.status(201).json({ success: true, id });
  } catch (error) {
    next(error);
  }
});

// 删除运动记录
router.delete('/:id', (req, res, next) => {
  try {
    const stmt = db.prepare('DELETE FROM workout_records WHERE id = ? AND user_id = ?');
    const result = stmt.run(req.params.id, req.userId);

    if (result.changes === 0) {
      return res.status(404).json({ error: 'Workout record not found' });
    }

    res.json({ success: true });
  } catch (error) {
    next(error);
  }
});

module.exports = router;
```

#### 2.10 src/routes/meals.js

```javascript
const express = require('express');
const { db } = require('../config/database');
const authMiddleware = require('../middleware/auth');

const router = express.Router();
router.use(authMiddleware);

// 获取所有饮食记录
router.get('/', (req, res, next) => {
  try {
    const { startDate, endDate, limit = 100 } = req.query;

    let query = 'SELECT * FROM meal_records WHERE user_id = ?';
    const params = [req.userId];

    if (startDate) {
      query += ' AND timestamp >= ?';
      params.push(startDate);
    }

    if (endDate) {
      query += ' AND timestamp <= ?';
      params.push(endDate);
    }

    query += ' ORDER BY timestamp DESC LIMIT ?';
    params.push(parseInt(limit));

    const stmt = db.prepare(query);
    const meals = stmt.all(...params);

    // 获取每个meal的food items
    const foodStmt = db.prepare('SELECT * FROM food_items WHERE meal_id = ?');
    const mealsWithItems = meals.map(meal => ({
      ...meal,
      items: foodStmt.all(meal.id)
    }));

    res.json(mealsWithItems);
  } catch (error) {
    next(error);
  }
});

// 创建或更新饮食记录
router.post('/', (req, res, next) => {
  const transaction = db.transaction((mealData) => {
    const { id, mealType, timestamp, items, notes } = mealData;

    if (!id || !mealType || !timestamp) {
      throw new Error('Missing required fields');
    }

    // 插入或更新meal记录
    const mealStmt = db.prepare(`
      INSERT INTO meal_records (id, user_id, meal_type, timestamp, notes, updated_at)
      VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
      ON CONFLICT(id) DO UPDATE SET
        meal_type = excluded.meal_type,
        timestamp = excluded.timestamp,
        notes = excluded.notes,
        updated_at = CURRENT_TIMESTAMP
    `);
    mealStmt.run(id, req.userId, mealType, timestamp, notes);

    // 删除旧的food items
    const deleteStmt = db.prepare('DELETE FROM food_items WHERE meal_id = ?');
    deleteStmt.run(id);

    // 插入新的food items
    if (items && items.length > 0) {
      const foodStmt = db.prepare(`
        INSERT INTO food_items (id, meal_id, name, calories, protein, carbs, fat, image_url)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `);

      for (const item of items) {
        foodStmt.run(
          item.id,
          id,
          item.name,
          item.calories,
          item.protein,
          item.carbs,
          item.fat,
          item.imageUrl
        );
      }
    }
  });

  try {
    transaction(req.body);
    res.status(201).json({ success: true, id: req.body.id });
  } catch (error) {
    next(error);
  }
});

// 删除饮食记录
router.delete('/:id', (req, res, next) => {
  try {
    const stmt = db.prepare('DELETE FROM meal_records WHERE id = ? AND user_id = ?');
    const result = stmt.run(req.params.id, req.userId);

    if (result.changes === 0) {
      return res.status(404).json({ error: 'Meal record not found' });
    }

    res.json({ success: true });
  } catch (error) {
    next(error);
  }
});

module.exports = router;
```

#### 2.11 src/routes/sleep.js

```javascript
const express = require('express');
const { db } = require('../config/database');
const authMiddleware = require('../middleware/auth');

const router = express.Router();
router.use(authMiddleware);

// 获取所有睡眠记录
router.get('/', (req, res, next) => {
  try {
    const { startDate, endDate, limit = 100 } = req.query;

    let query = 'SELECT * FROM sleep_records WHERE user_id = ?';
    const params = [req.userId];

    if (startDate) {
      query += ' AND date >= ?';
      params.push(startDate);
    }

    if (endDate) {
      query += ' AND date <= ?';
      params.push(endDate);
    }

    query += ' ORDER BY date DESC LIMIT ?';
    params.push(parseInt(limit));

    const stmt = db.prepare(query);
    const records = stmt.all(...params);

    res.json(records);
  } catch (error) {
    next(error);
  }
});

// 创建或更新睡眠记录
router.post('/', (req, res, next) => {
  try {
    const { id, date, bedtime, wakeTime, note, sleepQuality } = req.body;

    if (!id || !date || !bedtime || !wakeTime) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const stmt = db.prepare(`
      INSERT INTO sleep_records
      (id, user_id, date, bedtime, wake_time, note, sleep_quality, updated_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
      ON CONFLICT(id) DO UPDATE SET
        bedtime = excluded.bedtime,
        wake_time = excluded.wake_time,
        note = excluded.note,
        sleep_quality = excluded.sleep_quality,
        updated_at = CURRENT_TIMESTAMP
    `);

    stmt.run(id, req.userId, date, bedtime, wakeTime, note, sleepQuality);

    res.status(201).json({ success: true, id });
  } catch (error) {
    next(error);
  }
});

// 删除睡眠记录
router.delete('/:id', (req, res, next) => {
  try {
    const stmt = db.prepare('DELETE FROM sleep_records WHERE id = ? AND user_id = ?');
    const result = stmt.run(req.params.id, req.userId);

    if (result.changes === 0) {
      return res.status(404).json({ error: 'Sleep record not found' });
    }

    res.json({ success: true });
  } catch (error) {
    next(error);
  }
});

module.exports = router;
```

#### 2.12 src/routes/focus.js

```javascript
const express = require('express');
const { db } = require('../config/database');
const authMiddleware = require('../middleware/auth');

const router = express.Router();
router.use(authMiddleware);

// 获取所有专注记录
router.get('/', (req, res, next) => {
  try {
    const { startDate, endDate, limit = 100 } = req.query;

    let query = 'SELECT * FROM focus_sessions WHERE user_id = ?';
    const params = [req.userId];

    if (startDate) {
      query += ' AND start_time >= ?';
      params.push(startDate);
    }

    if (endDate) {
      query += ' AND start_time <= ?';
      params.push(endDate);
    }

    query += ' ORDER BY start_time DESC LIMIT ?';
    params.push(parseInt(limit));

    const stmt = db.prepare(query);
    const sessions = stmt.all(...params);

    res.json(sessions);
  } catch (error) {
    next(error);
  }
});

// 创建或更新专注记录
router.post('/', (req, res, next) => {
  try {
    const { id, startTime, endTime, targetMinutes, taskName, completed } = req.body;

    if (!id || !startTime || !endTime || targetMinutes === undefined) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const stmt = db.prepare(`
      INSERT INTO focus_sessions
      (id, user_id, start_time, end_time, target_minutes, task_name, completed, updated_at)
      VALUES (?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
      ON CONFLICT(id) DO UPDATE SET
        start_time = excluded.start_time,
        end_time = excluded.end_time,
        target_minutes = excluded.target_minutes,
        task_name = excluded.task_name,
        completed = excluded.completed,
        updated_at = CURRENT_TIMESTAMP
    `);

    stmt.run(id, req.userId, startTime, endTime, targetMinutes, taskName, completed ? 1 : 0);

    res.status(201).json({ success: true, id });
  } catch (error) {
    next(error);
  }
});

// 删除专注记录
router.delete('/:id', (req, res, next) => {
  try {
    const stmt = db.prepare('DELETE FROM focus_sessions WHERE id = ? AND user_id = ?');
    const result = stmt.run(req.params.id, req.userId);

    if (result.changes === 0) {
      return res.status(404).json({ error: 'Focus session not found' });
    }

    res.json({ success: true });
  } catch (error) {
    next(error);
  }
});

module.exports = router;
```

#### 2.13 src/routes/sync.js

```javascript
const express = require('express');
const { db } = require('../config/database');
const authMiddleware = require('../middleware/auth');

const router = express.Router();
router.use(authMiddleware);

// 批量同步数据
router.post('/batch', (req, res, next) => {
  const transaction = db.transaction((syncData) => {
    const { reviews, workouts, meals, sleep, focus } = syncData;

    // 同步reviews
    if (reviews && reviews.length > 0) {
      const stmt = db.prepare(`
        INSERT INTO review_entries
        (id, user_id, date, mood, highlights, improvements, tomorrow_plans, ai_summary, note, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
        ON CONFLICT(id) DO UPDATE SET
          mood = excluded.mood,
          highlights = excluded.highlights,
          improvements = excluded.improvements,
          tomorrow_plans = excluded.tomorrow_plans,
          ai_summary = excluded.ai_summary,
          note = excluded.note,
          updated_at = CURRENT_TIMESTAMP
      `);

      for (const entry of reviews) {
        stmt.run(
          entry.id,
          req.userId,
          entry.date,
          entry.mood,
          JSON.stringify(entry.highlights || []),
          JSON.stringify(entry.improvements || []),
          JSON.stringify(entry.tomorrowPlans || []),
          entry.aiSummary,
          entry.note
        );
      }
    }

    // 同步workouts (类似逻辑)
    // 同步meals (类似逻辑)
    // 同步sleep (类似逻辑)
    // 同步focus (类似逻辑)

    return {
      reviewsCount: reviews?.length || 0,
      workoutsCount: workouts?.length || 0,
      mealsCount: meals?.length || 0,
      sleepCount: sleep?.length || 0,
      focusCount: focus?.length || 0
    };
  });

  try {
    const result = transaction(req.body);
    res.json({ success: true, synced: result });
  } catch (error) {
    next(error);
  }
});

// 获取最后同步时间
router.get('/last-sync', (req, res, next) => {
  try {
    const queries = [
      'SELECT MAX(updated_at) as last_sync FROM review_entries WHERE user_id = ?',
      'SELECT MAX(updated_at) as last_sync FROM workout_records WHERE user_id = ?',
      'SELECT MAX(updated_at) as last_sync FROM meal_records WHERE user_id = ?',
      'SELECT MAX(updated_at) as last_sync FROM sleep_records WHERE user_id = ?',
      'SELECT MAX(updated_at) as last_sync FROM focus_sessions WHERE user_id = ?'
    ];

    const lastSyncTimes = queries.map(query => {
      const stmt = db.prepare(query);
      const result = stmt.get(req.userId);
      return result.last_sync;
    });

    const overallLastSync = lastSyncTimes
      .filter(time => time !== null)
      .sort()
      .reverse()[0];

    res.json({ lastSync: overallLastSync || null });
  } catch (error) {
    next(error);
  }
});

module.exports = router;
```

#### 2.14 src/index.js (主入口文件)

```javascript
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const { initDatabase } = require('./config/database');
const errorHandler = require('./middleware/errorHandler');

const authRoutes = require('./routes/auth');
const reviewRoutes = require('./routes/reviews');
const workoutRoutes = require('./routes/workouts');
const mealRoutes = require('./routes/meals');
const sleepRoutes = require('./routes/sleep');
const focusRoutes = require('./routes/focus');
const syncRoutes = require('./routes/sync');

const app = express();
const PORT = process.env.PORT || 3000;

// 初始化数据库
initDatabase();

// 安全中间件
app.use(helmet());

// CORS配置
const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || ['*'];
app.use(cors({
  origin: (origin, callback) => {
    if (!origin || allowedOrigins.includes('*') || allowedOrigins.some(allowed => {
      if (allowed.includes('*')) {
        const pattern = new RegExp(allowed.replace('*', '.*'));
        return pattern.test(origin);
      }
      return allowed === origin;
    })) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true
}));

// 请求限流
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15分钟
  max: 100, // 限制100个请求
  message: 'Too many requests from this IP, please try again later'
});
app.use('/api/', limiter);

// Body解析
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// 健康检查
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// API路由
app.use('/api/auth', authRoutes);
app.use('/api/reviews', reviewRoutes);
app.use('/api/workouts', workoutRoutes);
app.use('/api/meals', mealRoutes);
app.use('/api/sleep', sleepRoutes);
app.use('/api/focus', focusRoutes);
app.use('/api/sync', syncRoutes);

// 404处理
app.use((req, res) => {
  res.status(404).json({ error: 'Not found' });
});

// 错误处理
app.use(errorHandler);

// 启动服务器
app.listen(PORT, () => {
  console.log(`Coach Daily API Server running on port ${PORT}`);
  console.log(`Environment: ${process.env.NODE_ENV}`);
  console.log(`Database: ${process.env.DB_PATH}`);
});

// 优雅关闭
process.on('SIGTERM', () => {
  console.log('SIGTERM received, shutting down gracefully');
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('SIGINT received, shutting down gracefully');
  process.exit(0);
});
```

#### 2.15 ecosystem.config.js (PM2配置)

```javascript
module.exports = {
  apps: [{
    name: 'coach-daily-api',
    script: './src/index.js',
    instances: 1,
    exec_mode: 'fork',
    autorestart: true,
    watch: false,
    max_memory_restart: '200M',
    env: {
      NODE_ENV: 'production',
      PORT: 3000
    },
    error_file: './logs/err.log',
    out_file: './logs/out.log',
    log_file: './logs/combined.log',
    time: true
  }]
};
```

---

## 服务器部署步骤

### 前置要求

- Linux云服务器（推荐：Ubuntu 20.04+、CentOS 7+、Debian 11+）
- 最低配置：1核2GB内存、10GB磁盘
- 域名（可选，但强烈推荐用于HTTPS）
- SSH访问权限

### 步骤1：连接服务器并更新系统

```bash
# SSH连接服务器
ssh root@your-server-ip

# 更新系统包
apt update && apt upgrade -y  # Ubuntu/Debian
# 或
yum update -y  # CentOS
```

### 步骤2：安装Node.js

```bash
# 使用NodeSource安装Node.js 18 LTS
curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
apt install -y nodejs  # Ubuntu/Debian

# 或者使用nvm（推荐，方便版本管理）
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.5/install.sh | bash
source ~/.bashrc
nvm install 18
nvm use 18
nvm alias default 18

# 验证安装
node -v  # 应显示 v18.x.x
npm -v   # 应显示 9.x.x
```

### 步骤3：安装PM2进程管理器

```bash
npm install -g pm2

# 验证安装
pm2 -v
```

### 步骤4：创建应用目录和用户

```bash
# 创建专用用户（安全最佳实践）
useradd -m -s /bin/bash coach-daily
passwd coach-daily  # 设置密码

# 切换到应用用户
su - coach-daily

# 创建应用目录
mkdir -p ~/coach-daily-server
cd ~/coach-daily-server
```

### 步骤5：上传服务器代码

**方式A：使用Git（推荐）**

```bash
# 初始化git仓库
git init
git remote add origin your-git-repo-url
git pull origin main

# 或者创建新项目
npm init -y
# 然后复制上述所有代码文件到相应位置
```

**方式B：使用SCP从本地上传**

```bash
# 在本地执行（退出SSH后）
scp -r coach-daily-server/ coach-daily@your-server-ip:~/

# 或使用SFTP工具如FileZilla
```

**方式C：手动创建文件**

```bash
# 创建项目结构
mkdir -p src/{config,middleware,routes,utils} data logs

# 然后逐个创建并复制上述代码文件内容
nano package.json
# 粘贴package.json内容，Ctrl+X保存

nano .env
# 粘贴.env内容并修改配置

# 继续创建其他文件...
```

### 步骤6：配置环境变量

```bash
cd ~/coach-daily-server
nano .env
```

编辑 `.env` 文件，**务必修改以下内容**：

```bash
# 服务器配置
PORT=3000
NODE_ENV=production

# JWT密钥 - 必须修改！使用随机字符串（至少32字符）
JWT_SECRET=your_random_secret_key_min_32_chars_change_this_now_123456789
JWT_EXPIRES_IN=30d

# 数据库配置
DB_PATH=./data/coach_daily.db

# CORS配置 - 根据实际情况修改
ALLOWED_ORIGINS=https://yourdomain.com,http://localhost:*
```

**生成安全的JWT_SECRET：**

```bash
# 方法1：使用openssl
openssl rand -base64 32

# 方法2：使用node
node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"

# 将生成的随机字符串复制到JWT_SECRET
```

### 步骤7：安装依赖并测试

```bash
# 安装npm依赖
npm install

# 测试启动
node src/index.js

# 如果看到以下输出则成功：
# Database initialized successfully
# Coach Daily API Server running on port 3000
# Environment: production

# 按Ctrl+C停止测试
```

### 步骤8：使用PM2启动服务

```bash
# 启动应用
pm2 start ecosystem.config.js

# 查看状态
pm2 status

# 查看日志
pm2 logs coach-daily-api

# 停止应用
pm2 stop coach-daily-api

# 重启应用
pm2 restart coach-daily-api

# 设置开机自启
pm2 startup
pm2 save
```

### 步骤9：安装和配置Nginx

```bash
# 切回root用户
exit

# 安装Nginx
apt install -y nginx  # Ubuntu/Debian
# 或
yum install -y nginx  # CentOS

# 启动Nginx
systemctl start nginx
systemctl enable nginx

# 检查状态
systemctl status nginx
```

### 步骤10：配置Nginx反向代理

```bash
# 创建Nginx配置文件
nano /etc/nginx/sites-available/coach-daily

# 粘贴以下内容（先不使用HTTPS，后面再配置）：
```

```nginx
server {
    listen 80;
    server_name your-domain.com www.your-domain.com;  # 修改为你的域名

    # 限制请求大小
    client_max_body_size 10M;

    # API代理
    location /api/ {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;

        # 超时设置
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }

    # 健康检查
    location /health {
        proxy_pass http://localhost:3000/health;
        access_log off;
    }

    # 根路径返回API信息
    location / {
        return 200 '{"status":"ok","service":"Coach Daily API","version":"1.0.0"}';
        add_header Content-Type application/json;
    }
}
```

```bash
# 创建符号链接启用配置
ln -s /etc/nginx/sites-available/coach-daily /etc/nginx/sites-enabled/

# 测试Nginx配置
nginx -t

# 如果提示"syntax is ok"和"test is successful"，则重载Nginx
systemctl reload nginx
```

### 步骤11：配置防火墙

```bash
# Ubuntu/Debian (UFW)
ufw allow 22/tcp    # SSH
ufw allow 80/tcp    # HTTP
ufw allow 443/tcp   # HTTPS
ufw enable
ufw status

# CentOS (Firewalld)
firewall-cmd --permanent --add-service=ssh
firewall-cmd --permanent --add-service=http
firewall-cmd --permanent --add-service=https
firewall-cmd --reload
firewall-cmd --list-all
```

### 步骤12：配置SSL证书（HTTPS）

**使用Let's Encrypt免费证书（强烈推荐）：**

```bash
# 安装Certbot
apt install -y certbot python3-certbot-nginx  # Ubuntu/Debian
# 或
yum install -y certbot python3-certbot-nginx  # CentOS

# 自动获取并配置SSL证书
certbot --nginx -d your-domain.com -d www.your-domain.com

# 按提示输入邮箱，同意条款

# 测试自动续期
certbot renew --dry-run

# Certbot会自动设置cron任务每天检查证书是否需要续期
```

Certbot会自动修改Nginx配置，添加SSL相关配置。完成后的配置类似：

```nginx
server {
    listen 80;
    server_name your-domain.com www.your-domain.com;

    # 重定向HTTP到HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name your-domain.com www.your-domain.com;

    # SSL证书
    ssl_certificate /etc/letsencrypt/live/your-domain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/your-domain.com/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    # ... 其他配置保持不变 ...
}
```

### 步骤13：测试API

```bash
# 测试健康检查
curl http://your-domain.com/health
# 或
curl https://your-domain.com/health

# 应返回：{"status":"ok","timestamp":"2024-..."}

# 测试注册
curl -X POST https://your-domain.com/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{"username":"testuser","password":"test123456"}'

# 应返回：{"token":"eyJhbGc...","userId":"...","username":"testuser"}

# 测试登录
curl -X POST https://your-domain.com/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"testuser","password":"test123456"}'
```

### 步骤14：性能优化（可选）

```bash
# 编辑Nginx配置，添加缓存和压缩
nano /etc/nginx/nginx.conf

# 在http块中添加：
```

```nginx
http {
    # ... 现有配置 ...

    # Gzip压缩
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript
               application/x-javascript application/xml+rss
               application/json application/javascript;

    # 连接优化
    keepalive_timeout 65;
    keepalive_requests 100;

    # 缓存配置
    open_file_cache max=1000 inactive=20s;
    open_file_cache_valid 30s;
    open_file_cache_min_uses 2;
    open_file_cache_errors on;
}
```

```bash
# 重载Nginx
systemctl reload nginx
```

---

## 客户端集成指南

### 1. 创建API服务层

在Flutter项目中创建API服务：

#### 1.1 创建 `lib/shared/services/api_client.dart`

```dart
import 'package:dio/dio.dart';
import 'package:shared_preferences/shared_preferences.dart';

class ApiClient {
  late final Dio _dio;
  final String baseUrl;
  String? _token;

  ApiClient({required this.baseUrl}) {
    _dio = Dio(BaseOptions(
      baseUrl: baseUrl,
      connectTimeout: const Duration(seconds: 30),
      receiveTimeout: const Duration(seconds: 30),
      headers: {
        'Content-Type': 'application/json',
      },
    ));

    _dio.interceptors.add(InterceptorsWrapper(
      onRequest: (options, handler) async {
        if (_token != null) {
          options.headers['Authorization'] = 'Bearer $_token';
        }
        return handler.next(options);
      },
      onError: (error, handler) async {
        if (error.response?.statusCode == 401) {
          // Token过期，清除本地token
          await clearToken();
        }
        return handler.next(error);
      },
    ));

    _loadToken();
  }

  Future<void> _loadToken() async {
    final prefs = await SharedPreferences.getInstance();
    _token = prefs.getString('auth_token');
  }

  Future<void> setToken(String token) async {
    _token = token;
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('auth_token', token);
  }

  Future<void> clearToken() async {
    _token = null;
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove('auth_token');
  }

  bool get isAuthenticated => _token != null;

  // 认证API
  Future<Map<String, dynamic>> register(String username, String password) async {
    final response = await _dio.post('/auth/register', data: {
      'username': username,
      'password': password,
    });

    final token = response.data['token'];
    await setToken(token);

    return response.data;
  }

  Future<Map<String, dynamic>> login(String username, String password) async {
    final response = await _dio.post('/auth/login', data: {
      'username': username,
      'password': password,
    });

    final token = response.data['token'];
    await setToken(token);

    return response.data;
  }

  Future<void> logout() async {
    await clearToken();
  }

  // 通用请求方法
  Future<Response<T>> get<T>(String path, {Map<String, dynamic>? queryParameters}) {
    return _dio.get<T>(path, queryParameters: queryParameters);
  }

  Future<Response<T>> post<T>(String path, {dynamic data}) {
    return _dio.post<T>(path, data: data);
  }

  Future<Response<T>> delete<T>(String path) {
    return _dio.delete<T>(path);
  }
}
```

#### 1.2 创建API Provider `lib/shared/providers/api_provider.dart`

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../services/api_client.dart';

final apiClientProvider = Provider<ApiClient>((ref) {
  // 替换为你的实际域名
  return ApiClient(baseUrl: 'https://your-domain.com/api');
});
```

### 2. 修改Repository以支持远程同步

以 `ReviewRepository` 为例：

#### 2.1 修改 `lib/features/review/data/review_repository.dart`

```dart
import 'package:dio/dio.dart';
import '../../../shared/services/local_store.dart';
import '../../../shared/services/api_client.dart';
import '../domain/review_record.dart';

class ReviewRepository {
  ReviewRepository(this._store, this._api);

  final LocalStore _store;
  final ApiClient _api;

  static const _storageKey = 'review_entries';

  // 从本地获取
  Future<List<ReviewEntry>> fetchLocal() async {
    final entries = _store.readList(_storageKey, ReviewEntry.fromJson);
    entries.sort((a, b) => b.date.compareTo(a.date));
    return entries;
  }

  // 从服务器获取
  Future<List<ReviewEntry>> fetchFromServer({
    String? startDate,
    String? endDate,
    int limit = 100,
  }) async {
    try {
      final response = await _api.get('/reviews', queryParameters: {
        if (startDate != null) 'startDate': startDate,
        if (endDate != null) 'endDate': endDate,
        'limit': limit.toString(),
      });

      final List<dynamic> data = response.data;
      return data.map((json) => ReviewEntry.fromJson(json)).toList();
    } catch (e) {
      print('Error fetching from server: $e');
      return [];
    }
  }

  // 获取所有（优先服务器，失败则本地）
  Future<List<ReviewEntry>> fetchAll() async {
    if (_api.isAuthenticated) {
      try {
        final serverEntries = await fetchFromServer();
        // 缓存到本地
        await _store.writeList(_storageKey, serverEntries, (e) => e.toJson());
        return serverEntries;
      } catch (e) {
        print('Server fetch failed, using local: $e');
        return fetchLocal();
      }
    } else {
      return fetchLocal();
    }
  }

  // 保存（本地+服务器）
  Future<void> save(ReviewEntry entry) async {
    // 先保存到本地
    final entries = await fetchLocal();
    final index = entries.indexWhere((element) => element.id == entry.id);
    if (index >= 0) {
      entries[index] = entry;
    } else {
      entries.insert(0, entry);
    }
    await _store.writeList(_storageKey, entries, (entry) => entry.toJson());

    // 同步到服务器
    if (_api.isAuthenticated) {
      try {
        await _api.post('/reviews', data: {
          'id': entry.id,
          'date': entry.date.toIso8601String(),
          'mood': entry.mood,
          'highlights': entry.highlights,
          'improvements': entry.improvements,
          'tomorrowPlans': entry.tomorrowPlans,
          'aiSummary': entry.aiSummary,
          'note': entry.note,
        });
      } catch (e) {
        print('Server sync failed: $e');
        // 可以在这里标记为待同步
      }
    }
  }

  // 删除（本地+服务器）
  Future<void> delete(String id) async {
    // 先从本地删除
    final entries = await fetchLocal();
    entries.removeWhere((element) => element.id == id);
    await _store.writeList(_storageKey, entries, (entry) => entry.toJson());

    // 从服务器删除
    if (_api.isAuthenticated) {
      try {
        await _api.delete('/reviews/$id');
      } catch (e) {
        print('Server delete failed: $e');
      }
    }
  }

  // 批量同步本地数据到服务器
  Future<void> syncToServer() async {
    if (!_api.isAuthenticated) return;

    try {
      final localEntries = await fetchLocal();

      for (final entry in localEntries) {
        await _api.post('/reviews', data: {
          'id': entry.id,
          'date': entry.date.toIso8601String(),
          'mood': entry.mood,
          'highlights': entry.highlights,
          'improvements': entry.improvements,
          'tomorrowPlans': entry.tomorrowPlans,
          'aiSummary': entry.aiSummary,
          'note': entry.note,
        });
      }

      print('Synced ${localEntries.length} entries to server');
    } catch (e) {
      print('Batch sync failed: $e');
      rethrow;
    }
  }
}
```

#### 2.2 更新Repository Provider

在 `lib/features/review/application/review_providers.dart` 中：

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../shared/services/local_store.dart';
import '../../../shared/providers/api_provider.dart';
import '../data/review_repository.dart';
import '../domain/review_record.dart';

final reviewRepositoryProvider = Provider<ReviewRepository>((ref) {
  final store = ref.watch(localStoreProvider);
  final api = ref.watch(apiClientProvider);
  return ReviewRepository(store, api);
});

// ... 其他providers保持不变 ...
```

### 3. 创建认证页面

#### 3.1 创建 `lib/features/auth/presentation/auth_page.dart`

```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../shared/providers/api_provider.dart';

class AuthPage extends ConsumerStatefulWidget {
  const AuthPage({super.key});

  @override
  ConsumerState<AuthPage> createState() => _AuthPageState();
}

class _AuthPageState extends ConsumerState<AuthPage> {
  final _usernameController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _isLogin = true;
  bool _isLoading = false;
  String? _errorMessage;

  @override
  void dispose() {
    _usernameController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Future<void> _submit() async {
    if (_usernameController.text.isEmpty || _passwordController.text.isEmpty) {
      setState(() {
        _errorMessage = '请输入用户名和密码';
      });
      return;
    }

    if (_passwordController.text.length < 6) {
      setState(() {
        _errorMessage = '密码至少6个字符';
      });
      return;
    }

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final api = ref.read(apiClientProvider);

      if (_isLogin) {
        await api.login(_usernameController.text, _passwordController.text);
      } else {
        await api.register(_usernameController.text, _passwordController.text);
      }

      if (mounted) {
        // 登录成功，返回上一页或跳转到主页
        Navigator.of(context).pop(true);
      }
    } catch (e) {
      setState(() {
        _errorMessage = _isLogin ? '登录失败：用户名或密码错误' : '注册失败：用户名可能已存在';
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(_isLogin ? '登录' : '注册'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Text(
              _isLogin ? '欢迎回来' : '创建账号',
              style: Theme.of(context).textTheme.headlineMedium,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 48),
            TextField(
              controller: _usernameController,
              decoration: const InputDecoration(
                labelText: '用户名',
                border: OutlineInputBorder(),
                prefixIcon: Icon(Icons.person),
              ),
              enabled: !_isLoading,
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _passwordController,
              decoration: const InputDecoration(
                labelText: '密码',
                border: OutlineInputBorder(),
                prefixIcon: Icon(Icons.lock),
              ),
              obscureText: true,
              enabled: !_isLoading,
            ),
            if (_errorMessage != null) ...[
              const SizedBox(height: 16),
              Text(
                _errorMessage!,
                style: TextStyle(color: Theme.of(context).colorScheme.error),
                textAlign: TextAlign.center,
              ),
            ],
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: _isLoading ? null : _submit,
              child: _isLoading
                  ? const SizedBox(
                      height: 20,
                      width: 20,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : Text(_isLogin ? '登录' : '注册'),
            ),
            const SizedBox(height: 16),
            TextButton(
              onPressed: _isLoading
                  ? null
                  : () {
                      setState(() {
                        _isLogin = !_isLogin;
                        _errorMessage = null;
                      });
                    },
              child: Text(_isLogin ? '没有账号？点击注册' : '已有账号？点击登录'),
            ),
            const SizedBox(height: 24),
            Text(
              '提示：数据将同步到云端，可在多设备间共享',
              style: Theme.of(context).textTheme.bodySmall,
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }
}
```

### 4. 添加同步功能

#### 4.1 在设置页面添加同步按钮

在 `lib/features/profile/presentation/profile_page.dart` 中添加同步功能：

```dart
ListTile(
  leading: const Icon(Icons.cloud_sync),
  title: const Text('同步数据'),
  subtitle: Text(isAuthenticated ? '已登录，点击立即同步' : '未登录，点击登录'),
  onTap: () async {
    if (isAuthenticated) {
      // 执行同步
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (context) => const Center(child: CircularProgressIndicator()),
      );

      try {
        // 同步所有数据
        await ref.read(reviewRepositoryProvider).syncToServer();
        // 同步其他数据...

        if (context.mounted) {
          Navigator.pop(context);
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('同步成功')),
          );
        }
      } catch (e) {
        if (context.mounted) {
          Navigator.pop(context);
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('同步失败：$e')),
          );
        }
      }
    } else {
      // 跳转到登录页面
      final result = await Navigator.push(
        context,
        MaterialPageRoute(builder: (context) => const AuthPage()),
      );

      if (result == true && context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('登录成功')),
        );
      }
    }
  },
),
```

### 5. 自动同步策略（可选）

#### 5.1 创建同步服务 `lib/shared/services/sync_service.dart`

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../providers/api_provider.dart';

class SyncService {
  SyncService(this._ref);

  final Ref _ref;

  // 应用启动时同步
  Future<void> syncOnStartup() async {
    final api = _ref.read(apiClientProvider);
    if (!api.isAuthenticated) return;

    try {
      // 从服务器拉取最新数据
      // 实现拉取逻辑...

      print('Startup sync completed');
    } catch (e) {
      print('Startup sync failed: $e');
    }
  }

  // 定期同步（例如每30分钟）
  Stream<void> periodicSync(Duration interval) async* {
    while (true) {
      await Future.delayed(interval);

      final api = _ref.read(apiClientProvider);
      if (!api.isAuthenticated) continue;

      try {
        // 执行同步
        yield;
      } catch (e) {
        print('Periodic sync failed: $e');
      }
    }
  }
}

final syncServiceProvider = Provider<SyncService>((ref) {
  return SyncService(ref);
});
```

---

## 安全性配置

### 1. 服务器安全加固

#### 1.1 SSH安全配置

```bash
# 编辑SSH配置
nano /etc/ssh/sshd_config

# 修改以下配置：
Port 22022  # 修改SSH端口（避免常见扫描）
PermitRootLogin no  # 禁止root直接登录
PasswordAuthentication no  # 禁用密码登录，仅使用密钥
PubkeyAuthentication yes  # 启用公钥认证

# 重启SSH服务
systemctl restart sshd

# 注意：修改端口后记得更新防火墙规则
ufw allow 22022/tcp
ufw delete allow 22/tcp
```

#### 1.2 启用Fail2Ban防暴力破解

```bash
# 安装Fail2Ban
apt install -y fail2ban

# 创建配置文件
nano /etc/fail2ban/jail.local

# 添加以下内容：
```

```ini
[DEFAULT]
bantime = 3600
findtime = 600
maxretry = 5

[sshd]
enabled = true
port = 22022
logpath = /var/log/auth.log

[nginx-limit-req]
enabled = true
filter = nginx-limit-req
action = iptables-multiport[name=ReqLimit, port="http,https", protocol=tcp]
logpath = /var/log/nginx/error.log
```

```bash
# 启动Fail2Ban
systemctl enable fail2ban
systemctl start fail2ban

# 查看状态
fail2ban-client status
```

#### 1.3 定期自动更新

```bash
# 安装自动更新工具
apt install -y unattended-upgrades

# 启用自动更新
dpkg-reconfigure -plow unattended-upgrades
```

### 2. 应用层安全

#### 2.1 限流和防DDoS

在 `src/index.js` 中已经配置了基础限流，可以进一步加强：

```javascript
const rateLimit = require('express-rate-limit');

// 严格的认证端点限流
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5,  // 15分钟内最多5次登录尝试
  message: 'Too many login attempts, please try again later',
  standardHeaders: true,
  legacyHeaders: false,
});

app.use('/api/auth', authLimiter);

// 更严格的全局限流
const globalLimiter = rateLimit({
  windowMs: 1 * 60 * 1000,
  max: 30,  // 每分钟最多30个请求
});

app.use('/api/', globalLimiter);
```

#### 2.2 数据库备份加密

```bash
# 创建备份脚本（带加密）
nano ~/backup-db.sh
```

```bash
#!/bin/bash

BACKUP_DIR="/home/coach-daily/backups"
DB_PATH="/home/coach-daily/coach-daily-server/data/coach_daily.db"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/backup_$DATE.db"
ENCRYPTED_FILE="$BACKUP_FILE.gpg"
PASSWORD="your_backup_password"  # 修改为强密码

# 创建备份目录
mkdir -p $BACKUP_DIR

# 备份数据库
cp $DB_PATH $BACKUP_FILE

# 加密备份文件
echo $PASSWORD | gpg --batch --yes --passphrase-fd 0 -c $BACKUP_FILE

# 删除未加密的备份
rm $BACKUP_FILE

# 删除7天前的备份
find $BACKUP_DIR -name "backup_*.db.gpg" -mtime +7 -delete

echo "Backup completed: $ENCRYPTED_FILE"
```

```bash
# 添加执行权限
chmod +x ~/backup-db.sh

# 设置每天凌晨3点自动备份
crontab -e

# 添加以下行：
0 3 * * * /home/coach-daily/backup-db.sh >> /home/coach-daily/backup.log 2>&1
```

### 3. HTTPS强制和安全头

Nginx配置已经通过Certbot配置了HTTPS，可以进一步加强：

```bash
nano /etc/nginx/sites-available/coach-daily
```

在server块中添加：

```nginx
# 添加安全响应头
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
add_header X-Frame-Options "SAMEORIGIN" always;
add_header X-Content-Type-Options "nosniff" always;
add_header X-XSS-Protection "1; mode=block" always;
add_header Referrer-Policy "strict-origin-when-cross-origin" always;

# 禁止显示Nginx版本
server_tokens off;
```

---

## 备份与恢复

### 1. 手动备份

```bash
# 备份数据库
cp ~/coach-daily-server/data/coach_daily.db ~/coach_daily_backup_$(date +%Y%m%d).db

# 备份整个应用（包括配置）
tar -czf ~/coach-daily-full-backup-$(date +%Y%m%d).tar.gz \
  ~/coach-daily-server \
  --exclude='node_modules' \
  --exclude='logs'

# 下载到本地
# 在本地执行：
scp coach-daily@your-server-ip:~/coach-daily-full-backup-*.tar.gz ./
```

### 2. 自动远程备份（推荐）

使用rsync同步到另一台服务器或云存储：

```bash
# 安装rsync
apt install -y rsync

# 创建远程备份脚本
nano ~/remote-backup.sh
```

```bash
#!/bin/bash

LOCAL_DB="/home/coach-daily/coach-daily-server/data/coach_daily.db"
REMOTE_USER="backup-user"
REMOTE_HOST="backup-server-ip"
REMOTE_DIR="/backup/coach-daily"

# 使用rsync同步
rsync -avz --delete \
  -e "ssh -p 22" \
  $LOCAL_DB \
  $REMOTE_USER@$REMOTE_HOST:$REMOTE_DIR/

echo "Remote backup completed at $(date)"
```

### 3. 数据恢复

```bash
# 停止应用
pm2 stop coach-daily-api

# 恢复数据库
cp ~/coach_daily_backup_20240120.db ~/coach-daily-server/data/coach_daily.db

# 或从加密备份恢复
gpg -d ~/backups/backup_20240120_030001.db.gpg > ~/coach-daily-server/data/coach_daily.db

# 重启应用
pm2 restart coach-daily-api
```

---

## 监控与日志

### 1. PM2监控

```bash
# 实时监控
pm2 monit

# 查看日志
pm2 logs coach-daily-api

# 查看最近的错误
pm2 logs coach-daily-api --err

# 清空日志
pm2 flush
```

### 2. Nginx日志分析

```bash
# 查看访问日志
tail -f /var/log/nginx/access.log

# 查看错误日志
tail -f /var/log/nginx/error.log

# 分析访问统计
cat /var/log/nginx/access.log | awk '{print $1}' | sort | uniq -c | sort -nr | head -20

# 分析API端点访问频率
cat /var/log/nginx/access.log | grep "/api/" | awk '{print $7}' | sort | uniq -c | sort -nr
```

### 3. 系统资源监控

```bash
# 安装htop
apt install -y htop

# 查看系统资源
htop

# 查看磁盘使用
df -h

# 查看数据库大小
du -h ~/coach-daily-server/data/coach_daily.db

# 设置磁盘使用告警
nano ~/disk-alert.sh
```

```bash
#!/bin/bash

THRESHOLD=80
USAGE=$(df -h / | tail -1 | awk '{print $5}' | sed 's/%//')

if [ $USAGE -gt $THRESHOLD ]; then
  echo "Disk usage is above ${THRESHOLD}%: ${USAGE}%" | \
    mail -s "Disk Usage Alert" your-email@example.com
fi
```

### 4. 应用性能监控（可选）

安装PM2 Plus（免费版）：

```bash
# 注册PM2 Plus账号：https://app.pm2.io/

# 连接PM2到PM2 Plus
pm2 link your-secret-key your-public-key

# 设置应用名称
pm2 set pm2:app-name coach-daily-api
```

---

## 常见问题排查

### 1. API无法访问

**问题：**客户端无法连接到API

**排查步骤：**

```bash
# 1. 检查Node服务是否运行
pm2 status
pm2 logs coach-daily-api --lines 50

# 2. 检查端口是否监听
netstat -tulnp | grep 3000

# 3. 测试本地访问
curl http://localhost:3000/health

# 4. 检查Nginx状态
systemctl status nginx
nginx -t

# 5. 检查防火墙
ufw status
# 或
firewall-cmd --list-all

# 6. 检查SSL证书
certbot certificates

# 7. 测试外部访问
curl https://your-domain.com/health
```

### 2. 数据库锁定错误

**问题：**"database is locked" 错误

**解决方案：**

```javascript
// 在 src/config/database.js 中确保已启用WAL模式
db.pragma('journal_mode = WAL');
db.pragma('busy_timeout = 5000');  // 增加超时时间
```

### 3. JWT Token过期

**问题：**客户端频繁要求重新登录

**解决方案：**

1. 增加token过期时间（在 `.env` 中修改 `JWT_EXPIRES_IN`）
2. 实现token刷新机制：

```javascript
// 在 src/routes/auth.js 中添加刷新端点
router.post('/refresh', authMiddleware, (req, res) => {
  const newToken = generateToken(req.userId);
  res.json({ token: newToken });
});
```

### 4. 内存占用过高

**问题：**Node进程内存持续增长

**排查：**

```bash
# 查看PM2内存使用
pm2 monit

# 设置内存限制重启
pm2 start ecosystem.config.js --max-memory-restart 200M
```

### 5. 磁盘空间不足

**解决方案：**

```bash
# 清理PM2日志
pm2 flush

# 清理Nginx日志
truncate -s 0 /var/log/nginx/access.log
truncate -s 0 /var/log/nginx/error.log

# 设置日志轮转
apt install -y logrotate
```

---

## 其他可选方案

### 方案二：Docker + FastAPI + PostgreSQL

**适用场景：**需要更强大的查询能力、更好的扩展性、团队协作

**优点：**
- 容器化部署，环境一致性好
- PostgreSQL支持复杂查询和关系
- 易于横向扩展

**缺点：**
- 资源占用较大（建议2GB+内存）
- 配置相对复杂
- 维护成本较高

**快速部署：**

```yaml
# docker-compose.yml
version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: coach_daily
      POSTGRES_USER: coach_user
      POSTGRES_PASSWORD: secure_password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

  api:
    build: .
    ports:
      - "3000:8000"
    environment:
      DATABASE_URL: postgresql://coach_user:secure_password@postgres:5432/coach_daily
      JWT_SECRET: your_secret_key
    depends_on:
      - postgres
    restart: unless-stopped

volumes:
  postgres_data:
```

### 方案三：Supabase自托管

**适用场景：**需要完整的后端服务（认证、存储、实时订阅、边缘函数）

**优点：**
- 功能最全面
- 自带管理面板
- 支持实时数据同步

**缺点：**
- 资源占用最大（建议4GB+内存）
- 配置最复杂
- 可能过度设计

**部署参考：**https://supabase.com/docs/guides/self-hosting/docker

---

## 总结

### 推荐配置清单

**最小化部署（个人使用）：**
- ✅ Node.js + Express + SQLite
- ✅ PM2进程管理
- ✅ Nginx反向代理
- ✅ Let's Encrypt SSL
- ✅ 基础防火墙
- ✅ 每日自动备份

**生产级部署（团队使用）：**
- ✅ 上述所有配置
- ✅ Fail2Ban防暴力破解
- ✅ 远程备份
- ✅ PM2 Plus监控
- ✅ 日志轮转
- ✅ 定期安全更新

### 维护检查清单

**每周：**
- [ ] 检查PM2服务状态
- [ ] 查看错误日志
- [ ] 检查磁盘空间

**每月：**
- [ ] 更新系统包
- [ ] 检查SSL证书有效期
- [ ] 测试备份恢复
- [ ] 审查访问日志

**每季度：**
- [ ] 更新Node.js版本
- [ ] 审查安全配置
- [ ] 性能优化评估

---

## 技术支持

**遇到问题？**

1. 检查本文档的"常见问题排查"章节
2. 查看PM2日志：`pm2 logs coach-daily-api`
3. 查看Nginx错误日志：`tail -f /var/log/nginx/error.log`
4. 检查系统日志：`journalctl -xe`

**需要帮助？**

- Node.js文档：https://nodejs.org/docs
- Express文档：https://expressjs.com
- SQLite文档：https://sqlite.org/docs.html
- PM2文档：https://pm2.keymetrics.io/docs
- Nginx文档：https://nginx.org/en/docs

---

**文档版本：**1.0.0
**最后更新：**2024-01-20
**作者：**Claude
